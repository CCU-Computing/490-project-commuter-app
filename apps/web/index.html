<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Parking Tracker • API Test UI</title>
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <!-- Leaflet.Draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css">
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <style>
    :root{--bg:#0f1115;--panel:#171a21;--muted:#98a2b3;--fg:#e5e7eb;--accent:#6ee7b7;--accent2:#60a5fa;--red:#f87171}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.35 ui-sans-serif,system-ui,Segoe UI,Inter,Roboto,Helvetica,Arial}
    header{display:flex;gap:8px;align-items:center;padding:12px 16px;border-bottom:1px solid #222}
    header h1{font-size:16px;margin:0;font-weight:600}
    .tabs{display:flex;gap:6px;flex-wrap:wrap}
    .tab{padding:8px 10px;border:1px solid #262a33;border-radius:10px;background:#131720;cursor:pointer}
    .tab.active{border-color:#2b3342;background:#0f1420;box-shadow:0 0 0 1px #2b3342 inset}
    main{display:grid;grid-template-columns: 420px 1fr;gap:12px;padding:12px}
    .left, .right{min-height:calc(100dvh - 70px)}
    .left{display:flex;flex-direction:column;gap:12px}
    .panel{background:var(--panel);border:1px solid #232734;border-radius:14px}
    .panel h2{margin:0;padding:12px 14px;border-bottom:1px solid #232734;font-size:14px}
    .panel .body{padding:12px;display:flex;flex-direction:column;gap:10px}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:4px}
    input[type="text"], input[type="number"], textarea, select{width:100%;background:#0e1118;color:var(--fg);border:1px solid #2a3040;border-radius:10px;padding:8px 10px}
    textarea{min-height:90px}
    button{appearance:none;border:1px solid #2b3342;background:#111827;color:var(--fg);padding:8px 10px;border-radius:10px;cursor:pointer}
    button.primary{border-color:transparent;background:linear-gradient(180deg,var(--accent2),#2563eb);color:#fff}
    button.alert{border-color:transparent;background:linear-gradient(180deg,#ef4444,#dc2626);color:#fff}
    .row{display:flex;gap:8px}
    .row > *{flex:1}
    #map{height:100%;min-height:420px;border-radius:14px}
    .pill{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #2b3342;background:#0f1420;display:inline-block}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid #232734;padding:6px 8px;text-align:left;font-size:12px}
    kbd{background:#111827;border:1px solid #2b3342;border-bottom-color:#1d2431;padding:1px 6px;border-radius:6px}
    .muted{color:var(--muted)}
    .stack{display:flex;flex-direction:column;gap:6px}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
    .foot{padding:8px 12px;font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <h1>Parking Tracker • Test UI</h1>
    <div class="tabs" id="tabs">
      <div class="tab active" data-target="routes">Routes</div>
      <div class="tab" data-target="stops">Stops</div>
      <div class="tab" data-target="routeStops">Route Stops</div>
      <div class="tab" data-target="lots">Parking Lots</div>
      <div class="tab" data-target="fulfillment">Fulfillment</div>
      <div class="tab" data-target="raw">Raw / Debug</div>
    </div>
  </header>

  <main>
    <section class="left">
      <!-- ROUTES -->
      <div class="panel" data-panel="routes">
        <h2>Routes</h2>
        <div class="body">
          <div class="row">
            <button id="btnLoadRoutes">Load Routes</button>
            <button id="btnCreateRoute" class="primary">Create</button>
            <button id="btnUpdateRoute">Update</button>
            <button id="btnDeleteRoute" class="alert">Delete</button>
          </div>
          <div class="row">
            <input id="route_id" type="text" placeholder="route_id (GET/PUT/DELETE)" />
            <input id="route_name" type="text" placeholder="name" />
          </div>
          <div class="row">
            <input id="route_code" type="text" placeholder="code" />
            <input id="route_color" type="text" placeholder="color_hex (#RRGGBB)" />
          </div>
          <label>Geometry (GeoJSON Feature geometry or WKT)</label>
          <textarea id="route_geom" placeholder='{"type":"MultiLineString","coordinates":[[[-79,33.7],[-78.95,33.71]]]}'></textarea>
          <div class="row">
            <button id="btnUseDrawnRoute">Use drawn line(s)</button>
            <button id="btnClearDrawnLines">Clear drawn lines</button>
          </div>
          <div class="muted">Tip: draw polyline(s) on the map. We’ll wrap to <kbd>MultiLineString</kbd> for you.</div>
          <div id="routesTableWrap" class="stack"></div>
        </div>
      </div>

      <!-- STOPS -->
      <div class="panel" data-panel="stops" hidden>
        <h2>Stops</h2>
        <div class="body">
          <div class="row">
            <button id="btnLoadStops">Load Stops</button>
            <button id="btnCreateStop" class="primary">Create</button>
            <button id="btnUpdateStop">Update</button>
            <button id="btnDeleteStop" class="alert">Delete</button>
          </div>
          <div class="row">
            <input id="stop_id" type="text" placeholder="stop_id (GET/PUT/DELETE)" />
            <input id="stop_name" type="text" placeholder="name" />
          </div>
          <div class="row">
            <input id="stop_code" type="text" placeholder="code" />
            <input id="stop_direction" type="text" placeholder="direction (N/S/E/W)" />
          </div>
          <div class="row">
            <select id="stop_accessible"><option value="">accessible?</option><option>true</option><option>false</option></select>
            <select id="stop_shelter"><option value="">shelter?</option><option>true</option><option>false</option></select>
          </div>
          <label>Geometry (Point GeoJSON or WKT)</label>
          <textarea id="stop_geom" placeholder='{"type":"Point","coordinates":[-79.0,33.7]}'></textarea>
          <div class="row">
            <button id="btnUseDrawnPoint">Use drawn point</button>
            <button id="btnClearDrawnPoints">Clear drawn points</button>
          </div>
          <div id="stopsTableWrap" class="stack"></div>
        </div>
      </div>

      <!-- ROUTE STOPS -->
      <div class="panel" data-panel="routeStops" hidden>
        <h2>Route Stops</h2>
        <div class="body">
          <div class="row">
            <button id="btnLoadRouteStops">Load Route's Stops</button>
            <button id="btnUpsertRouteStop" class="primary">Upsert</button>
            <button id="btnDeleteRouteStop" class="alert">Delete</button>
          </div>
          <div class="row">
            <input id="rs_route_id" type="text" placeholder="route_id" />
            <input id="rs_stop_id" type="text" placeholder="stop_id" />
          </div>
          <div class="row">
            <input id="rs_seq" type="number" placeholder="seq (required for upsert)" />
            <input id="rs_dwell" type="number" placeholder="dwell_s (optional)" />
          </div>
          <input id="rs_distance" type="number" placeholder="distance_m (optional)" />
          <div id="routeStopsWrap" class="stack"></div>
          <div class="muted">Endpoints: <span class="pill mono">GET /routes/:id/stops</span> · <span class="pill mono">POST /routes/:routeId/stops</span> · <span class="pill mono">DELETE /routes/:routeId/stops/:stopId</span></div>
        </div>
      </div>

      <!-- PARKING LOTS -->
      <div class="panel" data-panel="lots" hidden>
        <h2>Parking Lots</h2>
        <div class="body">
          <div class="row">
            <button id="btnLotsRealtime">Realtime</button>
            <button id="btnLotsBest">Best (predicted)</button>
            <button id="btnLotsHist">Historical list</button>
            <button id="btnLotsGeoJSON">GeoJSON → Map</button>
          </div>
          <div class="row">
            <select id="lot_day">
              <option value="">day (default now)</option>
              <option>sunday</option><option>monday</option><option>tuesday</option><option>wednesday</option><option>thursday</option><option>friday</option><option>saturday</option>
            </select>
            <input id="lot_hour" type="number" placeholder="hour 0-23 (default now)" />
          </div>

          <h3 class="muted" style="margin:6px 0 0 0;font-size:12px">Import drawn polygons as lots</h3>
          <div class="row">
            <input id="lot_prefix" type="text" placeholder="code prefix (e.g., LOT_)" />
            <input id="lot_name_prefix" type="text" placeholder="name prefix (e.g., Lot )" />
          </div>
          <div class="row">
            <button id="btnImportDrawnLots" class="primary">POST /parking-lots/import-geojson</button>
            <button id="btnClearDrawnPolys" class="alert">Clear drawn polygons</button>
          </div>

          <div id="lotsWrap" class="stack"></div>
        </div>
      </div>

      <!-- FULFILLMENT -->
      <div class="panel" data-panel="fulfillment" hidden>
        <h2>Fulfillment</h2>
        <div class="body">
          <div class="row">
            <button id="btnLoadFulfill">Load</button>
            <button id="btnCreateFulfill" class="primary">Create</button>
            <button id="btnUpdateFulfill">Update</button>
            <button id="btnDeleteFulfill" class="alert">Delete</button>
          </div>
          <div class="row">
            <input id="ful_id" type="number" placeholder="usage_id (PUT/DELETE)" />
            <input id="ful_lot" type="number" placeholder="lot_id" />
          </div>
          <div class="row">
            <input id="ful_value" type="number" step="1" placeholder="occupied_count (int)" />
            <input id="ful_date" type="text" placeholder="sample_date (YYYY-MM-DD optional)" />
          </div>
          <div id="fulWrap" class="stack"></div>
        </div>
      </div>

      <!-- RAW / DEBUG -->
      <div class="panel" data-panel="raw" hidden>
        <h2>Raw / Debug</h2>
        <div class="body">
          <div class="row">
            <input id="raw_method" value="GET" />
            <input id="raw_path" value="/health" />
            <button id="btnRawSend" class="primary">Send</button>
          </div>
          <label>Body (JSON)</label>
          <textarea id="raw_body" class="mono" placeholder='{"key":"value"}'></textarea>
          <div class="stack">
            <label>Response</label>
            <textarea id="raw_out" class="mono" style="min-height:160px" readonly></textarea>
          </div>
        </div>
      </div>

      <div class="foot">Keyboard: <kbd>r</kbd> Load Routes · <kbd>s</kbd> Load Stops · <kbd>l</kbd> Realtime Lots · <kbd>f</kbd> Load Fulfillment</div>
    </section>

    <section class="right">
      <div id="map" class="panel"></div>
    </section>
  </main>

  <script>
    // ===== helpers =====
    const apiBase = ''; // same-origin
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    const j = (v) => JSON.stringify(v,null,2);
    const toJSON = (s)=>{ if(!s) return undefined; try{return JSON.parse(s)}catch{ return undefined } }
    const val = (id)=> (document.getElementById(id)?.value ?? '').trim();
    const esc = (s)=> String(s??'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]))

    async function x(method, path, body){
      const res = await fetch(apiBase + path, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: body ? JSON.stringify(body) : undefined
      });
      if(!res.ok){ const t = await res.text(); throw new Error(res.status+" "+t) }
      const ct = res.headers.get('content-type')||'';
      return ct.includes('application/json') ? res.json() : res.text();
    }

    function tableFromArray(arr, cols){
      if(!arr?.length){ return '<div class="muted">(empty)</div>' }
      const heads = cols || Object.keys(arr[0]);
      const header = '<tr>'+heads.map(h=>`<th>${h}</th>`).join('')+'</tr>';
      const rows = arr.map(r=>'<tr>'+heads.map(h=>`<td>${esc(h.split('.').reduce((o,k)=>o?.[k], r))}</td>`).join('')+'</tr>').join('');
      return `<table>${header}${rows}</table>`
    }

    // ===== UI: tabs =====
    $$('#tabs .tab').forEach(t=>t.addEventListener('click',()=>{
      $$('#tabs .tab').forEach(x=>x.classList.toggle('active', x===t));
      const tgt = t.dataset.target;
      $$('.panel[data-panel]').forEach(p=>p.hidden = p.dataset.panel!==tgt);
    }))

    // ===== Map + Layers =====
    const map = L.map('map', { zoomControl:true }).setView([33.79,-79.01], 15);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' }).addTo(map);

    const layers = {
      routes: L.geoJSON(null, { style: f=>({ color: f.properties?.color_hex || '#60a5fa', weight: 4 })}).addTo(map),
      stops: L.geoJSON(null, { pointToLayer: (f, latlng)=> L.circleMarker(latlng, { radius: 5 }) }).addTo(map),
      lots:  L.geoJSON(null, {
        style: f=>({ color: '#6ee7b7', weight:2, fillOpacity:0.25 }),
        onEachFeature: (f, layer)=>{
          const p=f.properties||{};
          layer.bindPopup(`<b>${esc(p.name||p.code||'Lot')}</b><br>cap: ${p.capacity??'n/a'}<br>occupied: ${p.occupied??'n/a'}<br>fulfillment: ${p.fulfillment??'n/a'}`);
        }
      }).addTo(map)
    };

    // Drawn layer (what you sketch)
    const drawn = new L.FeatureGroup();
    map.addLayer(drawn);

    const drawControl = new L.Control.Draw({
      draw: {
        polygon: { allowIntersection:false, showArea:true },
        polyline: { showLength:true },
        rectangle: false,
        circle: false,
        circlemarker: false,
        marker: true
      },
      edit: { featureGroup: drawn }
    });
    map.addControl(drawControl);

    map.on(L.Draw.Event.CREATED, (e)=>{
      drawn.addLayer(e.layer);
    });

    function fitAll(){
      const g = L.featureGroup([...Object.values(layers), drawn]);
      try{ map.fitBounds(g.getBounds().pad(0.1)) }catch{}
    }

    // ===== ROUTES =====
    $('#btnLoadRoutes').onclick = async ()=>{
      const fc = await x('GET','/routes');
      layers.routes.clearLayers(); layers.routes.addData(fc); fitAll();
      const list = (fc.features||[]).map(f=>({ route_id:f.id, name:f.properties?.name, code:f.properties?.code, color_hex:f.properties?.color_hex }));
      $('#routesTableWrap').innerHTML = tableFromArray(list, ['route_id','name','code','color_hex']);
    };

    function geometryFromDrawnLines(){
      // collect all polylines in 'drawn' and wrap into MultiLineString
      const lines = [];
      drawn.eachLayer(l=>{
        if(l instanceof L.Polyline && !(l instanceof L.Polygon)){
          const coords = l.getLatLngs().map(pt=>[+pt.lng.toFixed(6), +pt.lat.toFixed(6)]);
          lines.push(coords);
        }
      });
      if(!lines.length) return null;
      return { type:'MultiLineString', coordinates: lines };
    }

    $('#btnUseDrawnRoute').onclick = ()=>{
      const g = geometryFromDrawnLines();
      if(!g) return alert('Draw one or more polylines first.');
      $('#route_geom').value = j(g);
    };
    $('#btnClearDrawnLines').onclick = ()=>{
      const toRemove=[];
      drawn.eachLayer(l=>{ if(l instanceof L.Polyline && !(l instanceof L.Polygon)) toRemove.push(l) });
      toRemove.forEach(l=>drawn.removeLayer(l));
    };

    $('#btnCreateRoute').onclick = async ()=>{
      const body = {
        name: val('route_name')||undefined,
        code: val('route_code')||undefined,
        color_hex: val('route_color')||undefined,
        geometry: toJSON(val('route_geom')),
        wkt: val('route_geom') && !val('route_geom').trim().startsWith('{') ? val('route_geom') : undefined
      };
      const r = await x('POST','/routes', body);
      alert('created route_id='+r.route_id); $('#btnLoadRoutes').click();
    };
    $('#btnUpdateRoute').onclick = async ()=>{
      const id = val('route_id'); if(!id) return alert('route_id required');
      const body = {
        name: val('route_name')||undefined,
        code: val('route_code')||undefined,
        color_hex: val('route_color')||undefined,
        geometry: toJSON(val('route_geom')),
        wkt: val('route_geom') && !val('route_geom').trim().startsWith('{') ? val('route_geom') : undefined
      };
      const r = await x('PUT','/routes/'+id, body); alert('updated route_id='+r.route_id); $('#btnLoadRoutes').click();
    };
    $('#btnDeleteRoute').onclick = async ()=>{
      const id = val('route_id'); if(!id) return alert('route_id required');
      await x('DELETE','/routes/'+id); alert('deleted'); $('#btnLoadRoutes').click();
    };

    // ===== STOPS =====
    $('#btnLoadStops').onclick = async ()=>{
      const fc = await x('GET','/stops');
      layers.stops.clearLayers(); layers.stops.addData(fc); fitAll();
      const list = (fc.features||[]).map(f=>({ stop_id:f.id, name:f.properties?.name, code:f.properties?.code, direction:f.properties?.direction, accessible:f.properties?.accessible, shelter:f.properties?.shelter }));
      $('#stopsTableWrap').innerHTML = tableFromArray(list, ['stop_id','name','code','direction','accessible','shelter']);
    };

    function pointFromDrawn(){
      let pt=null;
      drawn.eachLayer(l=>{
        if(l instanceof L.Marker && !pt){
          const c=l.getLatLng(); pt=[+c.lng.toFixed(6), +c.lat.toFixed(6)];
        }
      });
      return pt?({ type:'Point', coordinates: pt }):null;
    }

    $('#btnUseDrawnPoint').onclick = ()=>{
      const g = pointFromDrawn();
      if(!g) return alert('Place a marker first.');
      $('#stop_geom').value = j(g);
    };
    $('#btnClearDrawnPoints').onclick = ()=>{
      const toRemove=[]; drawn.eachLayer(l=>{ if(l instanceof L.Marker) toRemove.push(l) }); toRemove.forEach(l=>drawn.removeLayer(l));
    };

    $('#btnCreateStop').onclick = async ()=>{
      const body = {
        name: val('stop_name')||undefined,
        code: val('stop_code')||undefined,
        direction: val('stop_direction')||undefined,
        accessible: val('stop_accessible')===''?undefined:(val('stop_accessible')==='true'),
        shelter: val('stop_shelter')===''?undefined:(val('stop_shelter')==='true'),
        geometry: toJSON(val('stop_geom')),
        wkt: val('stop_geom') && !val('stop_geom').trim().startsWith('{') ? val('stop_geom') : undefined
      };
      const r = await x('POST','/stops', body); alert('created stop_id='+r.stop_id); $('#btnLoadStops').click();
    };
    $('#btnUpdateStop').onclick = async ()=>{
      const id = val('stop_id'); if(!id) return alert('stop_id required');
      const body = {
        name: val('stop_name')||undefined,
        code: val('stop_code')||undefined,
        direction: val('stop_direction')||undefined,
        accessible: val('stop_accessible')===''?undefined:(val('stop_accessible')==='true'),
        shelter: val('stop_shelter')===''?undefined:(val('stop_shelter')==='true'),
        geometry: toJSON(val('stop_geom')),
        wkt: val('stop_geom') && !val('stop_geom').trim().startsWith('{') ? val('stop_geom') : undefined
      };
      const r = await x('PUT','/stops/'+id, body); alert('updated stop_id='+r.stop_id); $('#btnLoadStops').click();
    };
    $('#btnDeleteStop').onclick = async ()=>{
      const id = val('stop_id'); if(!id) return alert('stop_id required');
      await x('DELETE','/stops/'+id); alert('deleted'); $('#btnLoadStops').click();
    };

    // ===== ROUTE STOPS =====
    $('#btnLoadRouteStops').onclick = async ()=>{
      const id = val('rs_route_id'); if(!id) return alert('route_id required');
      const fc = await x('GET','/routes/'+id+'/stops');
      const list = (fc.features||[]).map(f=>({ stop_id:f.id, name:f.properties?.name, code:f.properties?.code, seq:f.properties?.seq }));
      $('#routeStopsWrap').innerHTML = tableFromArray(list, ['seq','stop_id','name','code']);
    };
    $('#btnUpsertRouteStop').onclick = async ()=>{
      const rid = val('rs_route_id'); const sid = val('rs_stop_id'); const seq = Number(val('rs_seq'));
      if(!rid || !sid || Number.isNaN(seq)) return alert('route_id, stop_id, seq required');
      const body = { stop_id: sid, seq };
      await x('POST','/routes/'+rid+'/stops', body); alert('upserted'); $('#btnLoadRouteStops').click();
    };
    $('#btnDeleteRouteStop').onclick = async ()=>{
      const rid = val('rs_route_id'); const sid = val('rs_stop_id');
      if(!rid || !sid) return alert('route_id & stop_id required');
      await x('DELETE',`/routes/${rid}/stops/${sid}`); alert('deleted'); $('#btnLoadRouteStops').click();
    };

    // ===== LOTS =====
    $('#btnLotsRealtime').onclick = async ()=>{
      const data = await x('GET','/parking-lots');
      const cols = ['id','name','capacity','occupied','fulfillment','timestamp'];
      $('#lotsWrap').innerHTML = tableFromArray(data, cols);
    };
    async function dayHourQS(){
      const day = val('lot_day')||undefined; const hour = val('lot_hour')||undefined;
      const qs = new URLSearchParams(); if(day) qs.set('day',day); if(hour) qs.set('hour',hour);
      const s = qs.toString(); return s?('?'+s):'';
    }
    $('#btnLotsBest').onclick = async ()=>{
      const data = await x('GET','/parking-lots/best'+await dayHourQS());
      $('#lotsWrap').innerHTML = '<div class="mono">'+esc(j(data))+'</div>';
    };
    $('#btnLotsHist').onclick = async ()=>{
      const data = await x('GET','/parking-lots/historical'+await dayHourQS());
      $('#lotsWrap').innerHTML = tableFromArray(data, Object.keys(data[0]||{}));
    };
    $('#btnLotsGeoJSON').onclick = async ()=>{
      const fc = await x('GET','/parking-lots/geojson');
      layers.lots.clearLayers(); layers.lots.addData(fc); fitAll();
      const flat = (fc.features||[]).map(f=>({ id:f.properties?.lot_id, code:f.properties?.code, name:f.properties?.name, fulfillment:f.properties?.fulfillment }));
      $('#lotsWrap').innerHTML = tableFromArray(flat, ['id','code','name','fulfillment']);
    };

    function polygonsFromDrawn(){
      const polys=[];
      drawn.eachLayer(l=>{
        if(l instanceof L.Polygon){
          const rings = l.getLatLngs()[0].map(pt=>[+pt.lng.toFixed(6), +pt.lat.toFixed(6)]);
          // ensure closed ring
          if(rings.length && (rings[0][0]!==rings.at(-1)[0] || rings[0][1]!==rings.at(-1)[1])) rings.push(rings[0]);
          polys.push({ type:'Polygon', coordinates:[rings] });
        }
      });
      return polys;
    }

    $('#btnImportDrawnLots').onclick = async ()=>{
      const polys = polygonsFromDrawn();
      if(!polys.length) return alert('Draw one or more polygons first.');
      const pref = val('lot_prefix') || 'LOT_';
      const namePref = val('lot_name_prefix') || 'Lot ';
      const features = polys.map((g, i)=>({ type:'Feature', properties:{ id: `${pref}${i+1}`, name: `${namePref}${i+1}` }, geometry: g }));
      const fc = { type:'FeatureCollection', features };
      await x('POST','/parking-lots/import-geojson', fc);
      alert(`Imported ${features.length} lot(s).`);
      $('#btnLotsGeoJSON').click();
    };

    $('#btnClearDrawnPolys').onclick = ()=>{
      const toRemove=[]; drawn.eachLayer(l=>{ if(l instanceof L.Polygon) toRemove.push(l) }); toRemove.forEach(l=>drawn.removeLayer(l));
    };

    // ===== FULFILLMENT (lot_usage_stats) =====
    $('#btnLoadFulfill').onclick = async ()=>{
      const data = await x('GET','/fulfillment');
      $('#fulWrap').innerHTML = tableFromArray(data, Object.keys(data[0]||{}));
    };
    $('#btnCreateFulfill').onclick = async ()=>{
      const body = {
        lot_id: Number(val('ful_lot')),
        occupied_count: Number(val('ful_value')),
        sample_date: val('ful_date') || undefined
      };
      const r = await x('POST','/fulfillment', body); alert('created usage_id='+r.usage_id); $('#btnLoadFulfill').click();
    };
    $('#btnUpdateFulfill').onclick = async ()=>{
      const id = val('ful_id'); if(!id) return alert('usage_id required');
      const body = {};
      if(val('ful_value')) body.occupied_count = Number(val('ful_value'));
      if(val('ful_date')) body.sample_date = val('ful_date');
      const r = await x('PUT','/fulfillment/'+id, body); alert('updated usage_id='+r.usage_id); $('#btnLoadFulfill').click();
    };
    $('#btnDeleteFulfill').onclick = async ()=>{
      const id = val('ful_id'); if(!id) return alert('usage_id required');
      await x('DELETE','/fulfillment/'+id); alert('deleted'); $('#btnLoadFulfill').click();
    };

    // ===== RAW =====
    $('#btnRawSend').onclick = async ()=>{
      try{ const out = await x(val('raw_method')||'GET', val('raw_path')||'/health', toJSON(val('raw_body'))); $('#raw_out').value = j(out) }
      catch(e){ $('#raw_out').value = String(e) }
    };

    // default load
    $('#btnLotsGeoJSON').click();
  </script>
</body>
</html>
